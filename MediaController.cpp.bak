#include "MediaController.h"
#include <QDebug>
#include <QRandomGenerator>
#include <QNetworkRequest>
#include <QBuffer>
#include <QImageReader>

// DBus includes for BlueZ integration
#ifndef Q_OS_WIN
#include <QDBusConnection>
#include <QDBusInterface>
#include <QDBusReply>
#include <QDBusMessage>
#include <QDBusMetaType>
#include <QDBusArgument>
#include <QProcess>
#endif

/**
 * CONSTRUCTOR
 *
 * Initializes the MediaController with default values.
 * Sets up timers for position tracking and mock data (if Windows).
 *
 * On Windows: Runs in mock mode with simulated music playback
 * On Linux/Embedded: Sets up real Bluetooth AVRCP connection
 */
MediaController::MediaController(QObject *parent)
    : QObject(parent)
    , m_isConnected(false)
    , m_deviceAddress("")
    , m_isPlaying(false)
    , m_repeatMode(RepeatOff)
    , m_shuffleEnabled(false)
    , m_trackTitle("No Track")
    , m_artist("Unknown Artist")
    , m_album("Unknown Album")
    , m_genre("")
    , m_trackPosition(0)
    , m_trackDuration(0)
    , m_volume(50)
    , m_savedVolume(50)
    , m_isMuted(false)
    , m_activeApp("")
    , m_audioSource("phone")
    , m_statusMessage("Ready")
    , m_positionTimer(new QTimer(this))
    , m_mockTimer(new QTimer(this))
    , m_networkManager(new QNetworkAccessManager(this))
#ifndef Q_OS_WIN
    , m_deviceInterface(nullptr)
    , m_mediaPlayerInterface(nullptr)
    , m_mediaControlInterface(nullptr)
    , m_mediaPlayerPath("")
    , m_pulseLoopbackModule(-1)
#endif
{
#ifdef Q_OS_WIN
    // ========== MOCK MODE (Windows Development) ==========
    m_mockMode = true;
    qDebug() << "MediaController: Running in MOCK mode (Windows)";
    setStatusMessage("Mock Mode - Simulated Bluetooth Music");

    // Simulate connection after 1 second
    QTimer::singleShot(1000, this, [this]() {
        m_isConnected = true;
        m_activeApp = "Spotify";
        emit connectionChanged();
        emit activeAppChanged();

        // Load initial mock track
        generateMockMusic();
        setStatusMessage("Mock: Connected to iPhone");
    });

    // Setup mock track changes every 3 minutes
    connect(m_mockTimer, &QTimer::timeout, this, &MediaController::simulateTrackChange);
    m_mockTimer->setInterval(180000); // 3 minutes

#else
    // ========== REAL MODE (Embedded Linux / Production) ==========
    m_mockMode = false;
    qDebug() << "MediaController: Real Bluetooth AVRCP mode";
    setStatusMessage("Ready to connect");
#endif

    // Setup position timer (updates every second while playing)
    connect(m_positionTimer, &QTimer::timeout, this, &MediaController::updatePosition);
    m_positionTimer->setInterval(1000);
}

/**
 * DESTRUCTOR
 *
 * Clean up resources
 */
MediaController::~MediaController()
{
#ifndef Q_OS_WIN
    // Clean up audio routing
    teardownAudioRouting();
    
    // Clean up DBus interfaces
    if (m_deviceInterface) {
        delete m_deviceInterface;
    }
    if (m_mediaPlayerInterface) {
        delete m_mediaPlayerInterface;
    }
    if (m_mediaControlInterface) {
        delete m_mediaControlInterface;
    }
#endif
}

/**
 * SET STATUS MESSAGE
 *
 * Updates the status message and emits signal for UI updates
 */
void MediaController::setStatusMessage(const QString &msg)
{
    if (m_statusMessage != msg) {
        m_statusMessage = msg;
        emit statusMessageChanged();
        qDebug() << "MediaController:" << msg;
    }
}

// ========================================================================
// CONNECTION MANAGEMENT
// ========================================================================

/**
 * CONNECT TO DEVICE
 *
 * Establishes AVRCP connection to phone's music service via BlueZ DBus
 *
 * Real Mode: Connects via DBus to BlueZ MediaPlayer1 interface
 * Mock Mode: Simulates connection
 */
void MediaController::connectToDevice(const QString &deviceAddress)
{
    m_deviceAddress = deviceAddress;

#ifdef Q_OS_WIN
    // Mock mode - simulate connection
    setStatusMessage("Mock: Connecting to music service...");

    QTimer::singleShot(1500, this, [this]() {
        m_isConnected = true;
        m_activeApp = "Apple Music";
        emit connectionChanged();
        emit activeAppChanged();

        generateMockMusic();
        setStatusMessage("Mock: Music control ready");
    });

#else
    // Real mode - connect via BlueZ DBus
    setStatusMessage("Connecting via BlueZ DBus...");
    
    qDebug() << "MediaController: Connecting to device:" << deviceAddress;
    
    // Convert address format: XX:XX:XX:XX:XX:XX → dev_XX_XX_XX_XX_XX_XX
    QString devicePath = "/org/bluez/hci0/" + addressToPath(deviceAddress);
    
    qDebug() << "MediaController: Device DBus path:" << devicePath;
    
    // Create Device interface
    if (m_deviceInterface) {
        delete m_deviceInterface;
    }
    
    m_deviceInterface = new QDBusInterface(
        "org.bluez",
        devicePath,
        "org.bluez.Device1",
        QDBusConnection::systemBus(),
        this
    );
    
    if (!m_deviceInterface->isValid()) {
        QString errorMsg = "Failed to create Device interface: " + 
                          m_deviceInterface->lastError().message();
        qWarning() << "MediaController:" << errorMsg;
        emit error(errorMsg);
        setStatusMessage("Connection failed");
        return;
    }
    
    // Check if device is connected
    QVariant connected = m_deviceInterface->property("Connected");
    if (!connected.toBool()) {
        qWarning() << "MediaController: Device not connected at system level";
        emit error("Device not connected. Please pair and connect first.");
        setStatusMessage("Device not connected");
        return;
    }
    
    qDebug() << "MediaController: Device is connected, finding MediaPlayer...";
    
    // Find MediaPlayer object path
    m_mediaPlayerPath = findMediaPlayerPath(devicePath);
    
    if (m_mediaPlayerPath.isEmpty()) {
        qWarning() << "MediaController: No MediaPlayer found for device";
        emit error("No media player found. Start playing music on your phone.");
        setStatusMessage("No media player detected");
        return;
    }
    
    qDebug() << "MediaController: MediaPlayer path:" << m_mediaPlayerPath;
    
    // Create MediaPlayer interface
    if (m_mediaPlayerInterface) {
        delete m_mediaPlayerInterface;
    }
    
    m_mediaPlayerInterface = new QDBusInterface(
        "org.bluez",
        m_mediaPlayerPath,
        "org.bluez.MediaPlayer1",
        QDBusConnection::systemBus(),
        this
    );
    
    if (!m_mediaPlayerInterface->isValid()) {
        QString errorMsg = "Failed to create MediaPlayer interface: " + 
                          m_mediaPlayerInterface->lastError().message();
        qWarning() << "MediaController:" << errorMsg;
        emit error(errorMsg);
        setStatusMessage("MediaPlayer connection failed");
        return;
    }
    
    // Create MediaControl interface
    if (m_mediaControlInterface) {
        delete m_mediaControlInterface;
    }
    
    m_mediaControlInterface = new QDBusInterface(
        "org.bluez",
        devicePath,
        "org.bluez.MediaControl1",
        QDBusConnection::systemBus(),
        this
    );
    
    // Setup property monitoring
    setupPropertyMonitoring(m_mediaPlayerPath);
    
    // Setup audio routing
    setupAudioRouting();
    
    // Read initial metadata
    QVariantMap track = m_mediaPlayerInterface->property("Track").toMap();
    if (!track.isEmpty()) {
        m_trackTitle = track.value("Title", "Unknown Track").toString();
        m_artist = track.value("Artist", "Unknown Artist").toString();
        m_album = track.value("Album", "Unknown Album").toString();
        m_trackDuration = track.value("Duration", 0).toLongLong();
        
        emit trackChanged();
        emit durationChanged();
        
        qDebug() << "MediaController: Initial track:" << m_trackTitle << "by" << m_artist;
    }
    
    // Read playback status
    QString status = m_mediaPlayerInterface->property("Status").toString();
    m_isPlaying = (status == "playing");
    
    if (m_isPlaying) {
        m_positionTimer->start();
    }
    
    // Get current position
    m_trackPosition = m_mediaPlayerInterface->property("Position").toLongLong();
    
    emit playStateChanged();
    emit positionChanged();
    
    // Connection successful
    m_isConnected = true;
    emit connectionChanged();
    
    // Try to determine which app is playing
    QString name = m_mediaPlayerInterface->property("Name").toString();
    if (!name.isEmpty()) {
        m_activeApp = name;
        emit activeAppChanged();
    }
    
    setStatusMessage("Connected to " + m_activeApp);
    qDebug() << "MediaController: Successfully connected to" << m_activeApp;
#endif
}

/**
 * DISCONNECT
 *
 * Closes AVRCP connection and tears down audio routing
 */
void MediaController::disconnect()
{
#ifdef Q_OS_WIN
    m_isConnected = false;
    m_isPlaying = false;
    m_positionTimer->stop();
    emit connectionChanged();
    emit playStateChanged();
    setStatusMessage("Mock: Disconnected");
#else
    qDebug() << "MediaController: Disconnecting...";
    
    // Tear down audio routing
    teardownAudioRouting();
    
    // Clean up interfaces
    if (m_deviceInterface) {
        delete m_deviceInterface;
        m_deviceInterface = nullptr;
    }
    if (m_mediaPlayerInterface) {
        delete m_mediaPlayerInterface;
        m_mediaPlayerInterface = nullptr;
    }
    if (m_mediaControlInterface) {
        delete m_mediaControlInterface;
        m_mediaControlInterface = nullptr;
    }
    
    m_mediaPlayerPath.clear();
    
    m_isConnected = false;
    m_isPlaying = false;
    m_positionTimer->stop();
    
    emit connectionChanged();
    emit playStateChanged();
    
    setStatusMessage("Disconnected");
    qDebug() << "MediaController: Disconnected successfully";
#endif
}

// ========================================================================
// PLAYBACK CONTROLS
// ========================================================================

/**
 * PLAY
 *
 * Sends AVRCP Play command via DBus MediaPlayer1
 */
void MediaController::play()
{
#ifdef Q_OS_WIN
    m_isPlaying = true;
    m_positionTimer->start();
    m_mockTimer->start();
    emit playStateChanged();
    setStatusMessage("Playing: " + m_trackTitle);
#else
    if (!m_mediaPlayerInterface || !m_mediaPlayerInterface->isValid()) {
        qWarning() << "MediaController: Cannot play - not connected";
        return;
    }
    
    qDebug() << "MediaController: Sending Play command";
    
    QDBusMessage reply = m_mediaPlayerInterface->call("Play");
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: Play failed:" << reply.errorMessage();
        emit error("Play failed: " + reply.errorMessage());
    } else {
        qDebug() << "MediaController: Play command sent successfully";
        // State will be updated via property change signal
    }
#endif
}

/**
 * PAUSE
 *
 * Sends AVRCP Pause command via DBus MediaPlayer1
 */
void MediaController::pause()
{
#ifdef Q_OS_WIN
    m_isPlaying = false;
    m_positionTimer->stop();
    m_mockTimer->stop();
    emit playStateChanged();
    setStatusMessage("Paused");
#else
    if (!m_mediaPlayerInterface || !m_mediaPlayerInterface->isValid()) {
        qWarning() << "MediaController: Cannot pause - not connected";
        return;
    }
    
    qDebug() << "MediaController: Sending Pause command";
    
    QDBusMessage reply = m_mediaPlayerInterface->call("Pause");
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: Pause failed:" << reply.errorMessage();
        emit error("Pause failed: " + reply.errorMessage());
    } else {
        qDebug() << "MediaController: Pause command sent successfully";
    }
#endif
}

/**
 * STOP
 *
 * Sends AVRCP Stop command via DBus MediaPlayer1
 *
 * Note: Stop resets position to 0, Pause keeps position
 */
void MediaController::stop()
{
#ifdef Q_OS_WIN
    m_isPlaying = false;
    m_trackPosition = 0;
    m_positionTimer->stop();
    m_mockTimer->stop();
    emit playStateChanged();
    emit positionChanged();
    setStatusMessage("Stopped");
#else
    if (!m_mediaPlayerInterface || !m_mediaPlayerInterface->isValid()) {
        qWarning() << "MediaController: Cannot stop - not connected";
        return;
    }
    
    qDebug() << "MediaController: Sending Stop command";
    
    QDBusMessage reply = m_mediaPlayerInterface->call("Stop");
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: Stop failed:" << reply.errorMessage();
        emit error("Stop failed: " + reply.errorMessage());
    } else {
        qDebug() << "MediaController: Stop command sent successfully";
    }
#endif
}

/**
 * TOGGLE PLAY/PAUSE
 *
 * Convenience method - plays if paused, pauses if playing
 */
void MediaController::togglePlayPause()
{
    if (m_isPlaying) {
        pause();
    } else {
        play();
    }
}

/**
 * NEXT TRACK
 *
 * Sends AVRCP Next command via DBus MediaPlayer1
 */
void MediaController::next()
{
#ifdef Q_OS_WIN
    simulateTrackChange();
    setStatusMessage("Next track");
#else
    if (!m_mediaPlayerInterface || !m_mediaPlayerInterface->isValid()) {
        qWarning() << "MediaController: Cannot skip next - not connected";
        return;
    }
    
    qDebug() << "MediaController: Sending Next command";
    
    QDBusMessage reply = m_mediaPlayerInterface->call("Next");
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: Next failed:" << reply.errorMessage();
        emit error("Next failed: " + reply.errorMessage());
    } else {
        qDebug() << "MediaController: Next command sent successfully";
    }
#endif
}

/**
 * PREVIOUS TRACK
 *
 * Sends AVRCP Previous command via DBus MediaPlayer1
 *
 * Note: If >3 seconds into track, restarts current track
 *       If <3 seconds, goes to previous track
 */
void MediaController::previous()
{
#ifdef Q_OS_WIN
    if (m_trackPosition > 3000) {
        // Restart current track
        m_trackPosition = 0;
        emit positionChanged();
        setStatusMessage("Restarting track");
    } else {
        // Go to previous track
        simulateTrackChange();
        setStatusMessage("Previous track");
    }
#else
    if (!m_mediaPlayerInterface || !m_mediaPlayerInterface->isValid()) {
        qWarning() << "MediaController: Cannot skip previous - not connected";
        return;
    }
    
    qDebug() << "MediaController: Sending Previous command";
    
    QDBusMessage reply = m_mediaPlayerInterface->call("Previous");
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: Previous failed:" << reply.errorMessage();
        emit error("Previous failed: " + reply.errorMessage());
    } else {
        qDebug() << "MediaController: Previous command sent successfully";
    }
#endif
}

/**
 * SEEK TO POSITION
 *
 * Seeks to specific position in current track
 *
 * @param positionMs: Target position in milliseconds
 *
 * Note: Not all phones support seeking via AVRCP
 *       iPhone requires AVRCP 1.5+
 */
void MediaController::seekTo(qint64 positionMs)
{
    if (positionMs < 0 || positionMs > m_trackDuration) {
        qWarning() << "Invalid seek position:" << positionMs;
        return;
    }

#ifdef Q_OS_WIN
    m_trackPosition = positionMs;
    emit positionChanged();
    setStatusMessage("Seeked to " + QString::number(positionMs / 1000) + "s");
#else
    // Send AVRCP seek command (AVRCP 1.5+)
    sendAvrcpCommand("SEEK:" + QString::number(positionMs));
#endif
}

/**
 * SKIP FORWARD
 *
 * Jumps forward by specified seconds
 */
void MediaController::skipForward(int seconds)
{
    qint64 newPos = qMin(m_trackPosition + (seconds * 1000), m_trackDuration);
    seekTo(newPos);
}

/**
 * SKIP BACKWARD
 *
 * Jumps backward by specified seconds
 */
void MediaController::skipBackward(int seconds)
{
    qint64 newPos = qMax(m_trackPosition - (seconds * 1000), (qint64)0);
    seekTo(newPos);
}

// ========================================================================
// VOLUME CONTROL
// ========================================================================

/**
 * SET VOLUME
 *
 * Sets absolute volume level
 *
 * @param level: Volume 0-100
 *
 * Command: AVRCP Absolute Volume (0x50)
 */
void MediaController::setVolume(int level)
{
    level = qBound(0, level, 100);

#ifdef Q_OS_WIN
    m_volume = level;
    m_isMuted = false;
    emit volumeChanged();
    setStatusMessage("Volume: " + QString::number(level) + "%");
#else
    sendAvrcpCommand("VOLUME:" + QString::number(level));
    m_volume = level;
    emit volumeChanged();
#endif
}

/**
 * VOLUME UP
 *
 * Increases volume by step amount
 */
void MediaController::volumeUp(int step)
{
    setVolume(m_volume + step);
}

/**
 * VOLUME DOWN
 *
 * Decreases volume by step amount
 */
void MediaController::volumeDown(int step)
{
    setVolume(m_volume - step);
}

/**
 * TOGGLE MUTE
 *
 * Mutes by saving current volume and setting to 0
 * Unmutes by restoring saved volume
 */
void MediaController::toggleMute()
{
    if (m_isMuted) {
        // Unmute - restore saved volume
        setVolume(m_savedVolume);
        m_isMuted = false;
    } else {
        // Mute - save current and set to 0
        m_savedVolume = m_volume;
        setVolume(0);
        m_isMuted = true;
    }
}

// ========================================================================
// PLAYBACK MODES
// ========================================================================

/**
 * SET REPEAT MODE
 *
 * Changes repeat mode: Off, All, or One
 *
 * Note: Requires AVRCP 1.4+ support on phone
 */
void MediaController::setRepeatMode(RepeatMode mode)
{
#ifdef Q_OS_WIN
    m_repeatMode = mode;
    emit repeatModeChanged();

    QString modeStr = (mode == RepeatOff) ? "Off" :
                          (mode == RepeatAll) ? "All" : "One";
    setStatusMessage("Repeat: " + modeStr);
#else
    sendAvrcpCommand("REPEAT:" + QString::number((int)mode));
    m_repeatMode = mode;
    emit repeatModeChanged();
#endif
}

/**
 * CYCLE REPEAT MODE
 *
 * Cycles through: Off Ã¢â€ â€™ All Ã¢â€ â€™ One Ã¢â€ â€™ Off
 */
void MediaController::cycleRepeatMode()
{
    RepeatMode newMode;
    switch (m_repeatMode) {
    case RepeatOff:
        newMode = RepeatAll;
        break;
    case RepeatAll:
        newMode = RepeatOne;
        break;
    case RepeatOne:
        newMode = RepeatOff;
        break;
    }
    setRepeatMode(newMode);
}

/**
 * SET SHUFFLE
 *
 * Enables or disables shuffle mode
 */
void MediaController::setShuffle(bool enabled)
{
#ifdef Q_OS_WIN
    m_shuffleEnabled = enabled;
    emit shuffleChanged();
    setStatusMessage("Shuffle: " + QString(enabled ? "On" : "Off"));
#else
    sendAvrcpCommand("SHUFFLE:" + QString(enabled ? "1" : "0"));
    m_shuffleEnabled = enabled;
    emit shuffleChanged();
#endif
}

/**
 * TOGGLE SHUFFLE
 *
 * Toggles shuffle on/off
 */
void MediaController::toggleShuffle()
{
    setShuffle(!m_shuffleEnabled);
}

// ========================================================================
// AUDIO SOURCE SWITCHING
// ========================================================================

/**
 * SET AUDIO SOURCE
 *
 * Switches between different audio sources:
 * - "phone": Bluetooth A2DP from phone
 * - "tidal": Local Tidal app
 * - "radio": FM/AM radio
 * - "aux": Auxiliary input
 * - "usb": USB media
 */
void MediaController::setAudioSource(const QString &source)
{
    if (m_audioSource != source) {
        m_audioSource = source;
        emit audioSourceChanged();
        setStatusMessage("Audio source: " + source);

        // When switching away from phone, pause playback
        if (source != "phone" && m_isPlaying) {
            pause();
        }
    }
}

// ========================================================================
// LIBRARY BROWSING
// ========================================================================

/**
 * REQUEST PLAYLISTS
 *
 * Requests list of playlists from phone
 *
 * Note: Requires AVRCP 1.4+ with browsing support
 *       Not all phones support this feature
 */
void MediaController::requestPlaylists()
{
#ifdef Q_OS_WIN
    // Generate mock playlists
    QVariantList playlists;
    playlists.append(QVariantMap{{"id", "1"}, {"name", "Favorites"}, {"trackCount", 47}});
    playlists.append(QVariantMap{{"id", "2"}, {"name", "Road Trip"}, {"trackCount", 32}});
    playlists.append(QVariantMap{{"id", "3"}, {"name", "Workout"}, {"trackCount", 28}});

    emit playlistsReceived(playlists);
    setStatusMessage("Loaded " + QString::number(playlists.size()) + " playlists");
#else
    sendAvrcpCommand("GET_PLAYLISTS");
#endif
}

/**
 * REQUEST ARTISTS
 *
 * Requests list of artists from phone library
 */
void MediaController::requestArtists()
{
#ifdef Q_OS_WIN
    QVariantList artists;
    artists.append("The Weeknd");
    artists.append("Dua Lipa");
    artists.append("Drake");
    artists.append("Taylor Swift");

    emit artistsReceived(artists);
#else
    sendAvrcpCommand("GET_ARTISTS");
#endif
}

/**
 * REQUEST ALBUMS
 *
 * Requests list of albums from phone library
 */
void MediaController::requestAlbums()
{
#ifdef Q_OS_WIN
    QVariantList albums;
    albums.append(QVariantMap{{"title", "After Hours"}, {"artist", "The Weeknd"}});
    albums.append(QVariantMap{{"title", "Future Nostalgia"}, {"artist", "Dua Lipa"}});

    emit albumsReceived(albums);
#else
    sendAvrcpCommand("GET_ALBUMS");
#endif
}

/**
 * PLAY PLAYLIST
 *
 * Starts playing specific playlist by ID
 */
void MediaController::playPlaylist(const QString &playlistId)
{
#ifdef Q_OS_WIN
    qDebug() << "Mock: Playing playlist" << playlistId;
    simulateTrackChange();
    play();
#else
    sendAvrcpCommand("PLAY_PLAYLIST:" + playlistId);
#endif
}

// ========================================================================
// POSITION TRACKING
// ========================================================================

/**
 * UPDATE POSITION
 *
 * Called every second by m_positionTimer while playing
 * Increments track position and emits signal for UI updates
 */
void MediaController::updatePosition()
{
    if (m_isPlaying && m_trackPosition < m_trackDuration) {
        m_trackPosition += 1000;
        emit positionChanged();

        // Check if track ended
        if (m_trackPosition >= m_trackDuration) {
            // Handle repeat mode
            if (m_repeatMode == RepeatOne) {
                m_trackPosition = 0;
                emit positionChanged();
            } else {
                // Auto-advance to next track
                next();
            }
        }
    }
}

// ========================================================================
// ALBUM ART MANAGEMENT
// ========================================================================

/**
 * DOWNLOAD ALBUM ART
 *
 * Downloads album artwork from URL provided in metadata
 *
 * @param url: Image URL (usually from music service API)
 */
void MediaController::downloadAlbumArt(const QUrl &url)
{
    if (!url.isValid()) {
        qDebug() << "Invalid album art URL";
        return;
    }

    QNetworkRequest request(url);
    QNetworkReply *reply = m_networkManager->get(request);

    connect(reply, &QNetworkReply::finished,
            this, &MediaController::onAlbumArtDownloaded);
}

/**
 * ON ALBUM ART DOWNLOADED
 *
 * Handles album art download completion
 * Loads image and emits signal for UI update
 */
void MediaController::onAlbumArtDownloaded()
{
    QNetworkReply *reply = qobject_cast<QNetworkReply*>(sender());
    if (!reply) return;

    if (reply->error() == QNetworkReply::NoError) {
        QByteArray imageData = reply->readAll();
        QBuffer buffer(&imageData);
        buffer.open(QIODevice::ReadOnly);

        QImageReader reader(&buffer);
        m_albumArtImage = reader.read();

        if (!m_albumArtImage.isNull()) {
            qDebug() << "Album art downloaded successfully";
            emit albumArtChanged();

/**
 * FIND MEDIA PLAYER PATH
 *
 * Searches for MediaPlayer1 interface under the device path
 * BlueZ creates player objects like: /org/bluez/hci0/dev_XX_XX_XX_XX_XX_XX/playerX
 */
QString MediaController::findMediaPlayerPath(const QString &devicePath)
{
    qDebug() << "MediaController: Searching for MediaPlayer under" << devicePath;
    
    QDBusInterface objectManager(
        "org.bluez",
        "/",
        "org.freedesktop.DBus.ObjectManager",
        QDBusConnection::systemBus()
    );
    
    // GetManagedObjects returns a{oa{sa{sv}}} - complex nested structure
    QDBusMessage reply = objectManager.call("GetManagedObjects");
    
    if (reply.type() == QDBusMessage::ErrorMessage) {
        qWarning() << "MediaController: GetManagedObjects failed:" << reply.errorMessage();
        return QString();
    }
    
    if (reply.arguments().isEmpty()) {
        qWarning() << "MediaController: GetManagedObjects returned no data";
        return QString();
    }
    
    // Parse the complex return value: a{oa{sa{sv}}}
    const QDBusArgument arg = reply.arguments().at(0).value<QDBusArgument>();
    
    arg.beginMap();
    while (!arg.atEnd()) {
        QString objPath;
        arg.beginMapEntry();
        arg >> objPath;
        
        if (objPath.startsWith(devicePath) && objPath.contains("player")) {
            // Found a player under our device
            QDBusArgument interfaces;
            arg >> interfaces;
            
            interfaces.beginMap();
            while (!interfaces.atEnd()) {
                QString interface;
                interfaces.beginMapEntry();
                interfaces >> interface;
                
                if (interface == "org.bluez.MediaPlayer1") {
                    // Found it! Clean up parsing and return
                    interfaces.endMapEntry();
                    interfaces.endMap();
                    arg.endMapEntry();
                    arg.endMap();
                    
                    qDebug() << "MediaController: Found MediaPlayer at" << objPath;
                    return objPath;
                }
                
                // Skip the properties dictionary
                QDBusArgument props;
                interfaces >> props;
                interfaces.endMapEntry();
            }
            interfaces.endMap();
        } else {
            // Skip this object's interfaces
            QDBusArgument interfaces;
            arg >> interfaces;
        }
        
        arg.endMapEntry();
    }
    arg.endMap();
    
    qWarning() << "MediaController: No MediaPlayer found under" << devicePath;
    return QString();
}
        }
    }
    
    qWarning() << "MediaController: No MediaPlayer found under" << devicePath;
    return QString();
}

/**
 * SETUP PROPERTY MONITORING
 *
 * Monitors DBus property changes for track metadata and playback status
 */
void MediaController::setupPropertyMonitoring(const QString &path)
{
    qDebug() << "MediaController: Setting up property monitoring for" << path;
    
    // Connect to PropertiesChanged signal
    bool connected = QDBusConnection::systemBus().connect(
        "org.bluez",
        path,
        "org.freedesktop.DBus.Properties",
        "PropertiesChanged",
        this,
        SLOT(onPropertiesChanged(QString,QVariantMap,QStringList))
    );
    
    if (connected) {
        qDebug() << "MediaController: Property monitoring enabled";
    } else {
        qWarning() << "MediaController: Failed to connect PropertiesChanged signal";
    }
}

/**
 * ON PROPERTIES CHANGED
 *
 * Handles DBus PropertiesChanged signals from MediaPlayer1
 */
void MediaController::onPropertiesChanged(const QString &interface,
                                         const QVariantMap &changedProperties,
                                         const QStringList &invalidatedProperties)
{
    Q_UNUSED(invalidatedProperties)
    
    if (interface != "org.bluez.MediaPlayer1") {
        return;
    }
    
    qDebug() << "MediaController: Properties changed:" << changedProperties.keys();
    
    // Handle track metadata changes
    if (changedProperties.contains("Track")) {
        QVariantMap track = changedProperties.value("Track").toMap();
        
        bool trackMetadataChanged = false;
        
        if (track.contains("Title")) {
            QString newTitle = track.value("Title").toString();
            if (m_trackTitle != newTitle) {
                m_trackTitle = newTitle;
                trackMetadataChanged = true;
            }
        }
        
        if (track.contains("Artist")) {
            QString newArtist = track.value("Artist").toString();
            if (m_artist != newArtist) {
                m_artist = newArtist;
                trackMetadataChanged = true;
            }
        }
        
        if (track.contains("Album")) {
            QString newAlbum = track.value("Album").toString();
            if (m_album != newAlbum) {
                m_album = newAlbum;
                trackMetadataChanged = true;
            }
        }
        
        if (track.contains("Duration")) {
            qint64 newDuration = track.value("Duration").toLongLong();
            if (m_trackDuration != newDuration) {
                m_trackDuration = newDuration;
                emit durationChanged();
            }
        }
        
        if (trackMetadataChanged) {
            emit trackChanged();
            setStatusMessage("Now playing: " + m_trackTitle);
            qDebug() << "MediaController: Track changed to:" << m_trackTitle << "by" << m_artist;
        }
    }
    
    // Handle playback status changes
    if (changedProperties.contains("Status")) {
        QString status = changedProperties.value("Status").toString();
        bool wasPlaying = m_isPlaying;
        m_isPlaying = (status == "playing");
        
        if (m_isPlaying != wasPlaying) {
            if (m_isPlaying) {
                m_positionTimer->start();
                setStatusMessage("Playing: " + m_trackTitle);
            } else {
                m_positionTimer->stop();
                setStatusMessage("Paused");
            }
            emit playStateChanged();
        }
        
        qDebug() << "MediaController: Playback status:" << status;
    }
    
    // Handle position changes
    if (changedProperties.contains("Position")) {
        m_trackPosition = changedProperties.value("Position").toLongLong();
        emit positionChanged();
    }
}

/**
 * SETUP AUDIO ROUTING
 *
 * Creates PulseAudio loopback from Bluetooth A2DP source to output sink
 * This routes the bit-perfect digital audio from phone to the DAC/amplifier
 */
void MediaController::setupAudioRouting()
{
    qDebug() << "MediaController: Setting up audio routing...";
    
    // Build the Bluetooth source name
    // Format: bluez_source.XX_XX_XX_XX_XX_XX.a2dp_source
    QString btSource = "bluez_source." + m_deviceAddress;
    btSource.replace(":", "_");
    btSource += ".a2dp_source";
    
    qDebug() << "MediaController: Bluetooth source:" << btSource;
    
    // Target sink - typically the default ALSA output
    // You can customize this to your specific audio hardware
    QString targetSink = "alsa_output.platform-sound.analog-stereo";
    
    // Create PulseAudio loopback module
    QProcess pactl;
    QStringList args;
    args << "load-module" << "module-loopback"
         << QString("source=%1").arg(btSource)
         << QString("sink=%1").arg(targetSink)
         << "latency_msec=1";  // Low latency for automotive use
    
    pactl.start("pactl", args);
    pactl.waitForFinished(3000);
    
    QString output = pactl.readAllStandardOutput().trimmed();
    QString error = pactl.readAllStandardError().trimmed();
    
    if (pactl.exitCode() == 0 && !output.isEmpty()) {
        m_pulseLoopbackModule = output.toInt();
        qDebug() << "MediaController: Audio routing created, module ID:" << m_pulseLoopbackModule;
        setStatusMessage("Audio routing active");
    } else {
        qWarning() << "MediaController: Failed to create audio routing:" << error;
        emit this->error("Audio routing failed: " + error);
        m_pulseLoopbackModule = -1;
    }
}

/**
 * TEARDOWN AUDIO ROUTING
 *
 * Removes PulseAudio loopback module when disconnecting
 */
void MediaController::teardownAudioRouting()
{
    if (m_pulseLoopbackModule < 0) {
        return;  // No module to tear down
    }
    
    qDebug() << "MediaController: Tearing down audio routing, module ID:" << m_pulseLoopbackModule;
    
    QProcess pactl;
    QStringList args;
    args << "unload-module" << QString::number(m_pulseLoopbackModule);
    
    pactl.start("pactl", args);
    pactl.waitForFinished(3000);
    
    if (pactl.exitCode() == 0) {
        qDebug() << "MediaController: Audio routing removed successfully";
        m_pulseLoopbackModule = -1;
    } else {
        qWarning() << "MediaController: Failed to remove audio routing:" 
                   << pactl.readAllStandardError();
    }
}

#endif

/**
 * SEND AVRCP COMMAND
 *
 * Legacy method - kept for compatibility but now uses DBus directly
 * Real implementations are in play(), pause(), next(), previous() methods
 */
void MediaController::sendAvrcpCommand(const QString &command)
{
#ifdef Q_OS_WIN
    qDebug() << "Mock AVRCP command:" << command;
#else
    qDebug() << "MediaController: sendAvrcpCommand called with:" << command;
    // Commands are now sent directly via DBus in individual methods
    // This function kept for compatibility
#endif
}

/**
 * PARSE AVRCP RESPONSE
 *
 * Legacy method - kept for compatibility
 * Metadata now comes via DBus PropertiesChanged signals
 */
void MediaController::parseAvrcpResponse(const QString &response)
{
    qDebug() << "MediaController: parseAvrcpResponse called (legacy):" << response;
    // Response parsing now handled by onPropertiesChanged in DBus mode
}

// ========================================================================
// MOCK DATA GENERATION (Testing Only)
// ========================================================================

/**
 * GENERATE MOCK MUSIC
 *
 * Creates fake track data for Windows testing
 */
void MediaController::generateMockMusic()
{
    QStringList tracks = {
        "Blinding Lights|The Weeknd|After Hours|200000",
        "Levitating|Dua Lipa|Future Nostalgia|203000",
        "Starboy|The Weeknd|Starboy|230000",
        "Don't Start Now|Dua Lipa|Future Nostalgia|183000",
        "One Dance|Drake|Views|173000"
    };

    QString track = tracks.at(QRandomGenerator::global()->bounded(tracks.size()));
    QStringList parts = track.split("|");

    m_trackTitle = parts[0];
    m_artist = parts[1];
    m_album = parts[2];
    m_trackDuration = parts[3].toLongLong();
    m_trackPosition = 0;

    // Generate mock album art URL
    m_albumArtUrl = QUrl("https://via.placeholder.com/300x300/00f0ff/0a0a0f?text=" + m_trackTitle);

    emit trackChanged();
    emit durationChanged();
    emit positionChanged();
    emit albumArtChanged();

    qDebug() << "Mock track loaded:" << m_trackTitle << "by" << m_artist;
}

/**
 * SIMULATE TRACK CHANGE
 *
 * Loads a random mock track (for testing)
 */
void MediaController::simulateTrackChange()
{
    generateMockMusic();

    if (m_isPlaying) {
        setStatusMessage("Now playing: " + m_trackTitle);
    }
}
